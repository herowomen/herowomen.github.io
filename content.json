{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"MSP","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"vue基本用法总结","slug":"vue基本用法总结","date":"2019-11-26T00:07:18.684Z","updated":"2019-11-26T00:42:58.342Z","comments":true,"path":"2019/11/26/vue基本用法总结/","link":"","permalink":"http://yoursite.com/2019/11/26/vue%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"目录： 一、vue实例的基本结构 二、vue事件处理、绑定属性 三、vue指令、自定义指令 四、vue过滤器 五、vue数据监听 六、vue组件 七、vue-router 八、axios 一、Vue 实例的基本结构Vue官网API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;p&gt; &lt;/div&gt; Welcomevar vm = new Vue(&#123; el: '#app', //等价于后面的 .$mount('#app') 用其中之一就可以了 render: h =&gt; h(App), //理解不够深入，参考（https://cn.vuejs.org/v2/api/?#render） data: &#123; //页面响应的数据都放在这里如上（组件只接受 function 且必须返回一个对象），zhicvm.$data 访问这里面的data msg: 'Welcome', &#125;, props:&#123; //props 可以是数组或对象，接收任何值 &#125;, methods: &#123; //页面或组件定义的方法的集合，可通过 vm.reset() 直接调用 reset: function()&#123; this.msg = '这是重新设置之后的数据' &#125; &#125;, computed: &#123; //计算属性(computed)与方法(methods) 类似，如果计算数据量比较大，建议放到这里 //计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。 //参考（https://cn.vuejs.org/v2/api/?#computed） &#125;, components：&#123; // 局部组件注册的地方 'component-a': ComponentA, 'component-b': ComponentB &#125;, directives: &#123; // 局部指令注册的地方 focus: &#123; // 指令的定义 inserted: function (el,binding) &#123; el.focus(); &#125; &#125; &#125;, filters:&#123; // 局部过滤器注册的地方 &#125;, //生命周期钩子 beforeCreate: function ()&#123;&#125;, //在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created: function ()&#123;&#125;,//在实例创建完成后被立即调用。 beforeMount: function ()&#123;&#125;,//在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted: function ()&#123;&#125;,//el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 beforeUpdate: function ()&#123;&#125;,//数据更新时调用，发生在虚拟 DOM 打补丁之前。 updated: function ()&#123;&#125;,//由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 beforeDestroy: function ()&#123;&#125;,//实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed: function ()&#123; //Vue 实例销毁后调用。 //调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 &#125;,&#125;).$mount('#app') 二、Vue 事件处理、绑定属性v-on： 1、绑定事件监听器。用在普通元素上时，只能监听原生 DOM 事件（如：click、keyup/down、mouseenter/over/move/down/out 等）。也可以监听自定义事件即 methods 里面的事件。 2、在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=”handle(‘ok’, $event)”。 123456789101112131415161718192021222324252627修饰符：.stop - 调用 event.stopPropagation()。阻止冒泡.prevent - 调用 event.preventDefault()。阻止默认事件.capture - 添加事件侦听器时使用 capture 模式。.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。.&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。.native - 监听组件根元素的原生事件。.once - 只触发一次回调。.left - (2.2.0) 只当点击鼠标左键时触发。.right - (2.2.0) 只当点击鼠标右键时触发。.middle - (2.2.0) 只当点击鼠标中键时触发。.passive - (2.3.0) 以 &#123; passive: true &#125; 模式添加侦听器用法：&lt;!-- 内联语句 --&gt;&lt;button v-on:click=\"doThat('hello', $event)\"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on=\"&#123; mousedown: doThis, mouseup: doThat &#125;\"&gt;&lt;/button&gt;... v-on 还提供了按键修饰符 12345678910111213键盘按钮的别名.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right// 可以通过全局 `config.keyCodes` 对象自定义按键修饰符别名// 使用 方式 `v-on:keyup.f1` ，f1 这个名字你可以任意取，你知道是什么意思就可以了Vue.config.keyCodes.f1 = 112 v-bind： 动态地绑定一个或多个特性，或一个组件 prop 到表达式。 1234567891011121314151617181920212223242526&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=\"imageSrc\"&gt;&lt;!-- 缩写 --&gt;&lt;img :src=\"imageSrc\"&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=\"'/path/to/images/' + fileName\"&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=\"&#123; red: isRed &#125;\"&gt;&lt;/div&gt;&lt;div :class=\"[classA, classB]\"&gt;&lt;/div&gt;&lt;div :class=\"[classA, &#123; classB: isB, classC: isC &#125;]\"&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=\"&#123; fontSize: size + 'px' &#125;\"&gt;&lt;/div&gt;&lt;div :style=\"[styleObjectA, styleObjectB]\"&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=\"&#123; id: someProp, 'other-attr': otherProp &#125;\"&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=\"someThing\"&gt;&lt;/my-component&gt;... 三、Vue 指令、自定义指令Vue指令： v-text： 123&lt;span v-text=\"msg\"&gt;&lt;/span&gt;&lt;!-- 和下面的一样 --&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; v-html： 123456//输出真正的 HTML&lt;div v-html=\"html\"&gt;&lt;/div&gt;data&#123; html:'&lt;strong&gt;我是真正的html&lt;/strong&gt;'&#125; v-show： 12//根据表达式之真假值，切换元素的 display CSS 属性。&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; v-if、v-if-else、v-else： 123456789101112//v-if 是“真正”的条件渲染，如果条件为假，dom不会渲染在页面当中//v-show 会一直渲染在dom当中//当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt;&lt;div v-if=\"type === 'A'\"&gt;A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt;B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt;C&lt;/div&gt;&lt;div v-else&gt;Not A/B/C&lt;/div&gt; v-for： 123456789//基于源数据多次渲染元素或模板块。&lt;div v-for=\"item in items\"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt;//另外也可以为数组索引指定别名 (或者用于对象的键)：val-&gt;对象的键值 key-&gt;对象的键 index-&gt;对象的下标&lt;div v-for=\"(item, index) in items\"&gt;&lt;/div&gt;&lt;div v-for=\"(val, key) in object\"&gt;&lt;/div&gt;&lt;div v-for=\"(val, key, index) in object\"&gt;&lt;/div&gt; v-model：作用于、、， 当v-model作用于 多个复选框、当选择按钮、选择框 时，都是把这些标签的value值赋值给v-model的变量 12345678910111213141516171819202122232425修饰符：.lazy - 取代 `input` 监听 `change` 事件.number- 输入字符串转为数字.trim- 输入首尾空格过滤&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;textarea v-model=\"message\" placeholder=\"add multiple lines\"&gt;&lt;/textarea&gt;// 选择框&lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;// 用 v-for 渲染的动态选项：&lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;... v-pre： 123//跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。//Mustache 标签：&#123;&#123; &#125;&#125;&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt; v-cloak： 123456789//这个指令保持在元素上直到关联实例结束编译css:[v-cloak] &#123; display: none;&#125;html:&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; v-once： 123456789101112131415只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment=\"msg\"&gt;&lt;/my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt; &lt;li v-for=\"i in list\" v-once&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; Vue自定义指令： 指令的钩子函数： 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： 1234567891011`bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。`inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。`update`：1、所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。 2、指令的值可能发生了改变，也可能没有。 3、你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。`componentUpdated`：指令所在组件的 VNode 及其子 VNode 全部更新后调用。`unbind`：只调用一次，指令与元素解绑时调用。 钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。 12345678910111213141516171819202122232425262728293031323334353637`el`：指令所绑定的元素，可以用来直接操作 DOM 。`binding`：一个对象，包含以下属性： `name`：指令名，不包括 `v-` 前缀。 `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。 `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。 `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。 `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。 `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `&#123; foo: true, bar: true &#125;`。`vnode`：Vue 编译生成的虚拟节点。移步(https://cn.vuejs.org/v2/api/#VNode%E6%8E%A5%E5%8F%A3) 来了解更多详情。`oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。// 注册一个全局自定义指令 `v-focus`// 在这里需要注意一下，给一个全局指令命名的时候不要加 `v-` 前缀，用在dom的时候再加上Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el,binding) &#123; // 聚焦元素 el.focus(); console.log(binding.value) //=&gt;666 &#125;&#125;)//如果想注册局部指令，组件中也接受一个 directives 的选项：directives: &#123; focus: &#123; // 指令的定义 inserted: function (el,binding) &#123; el.focus(); console.log(binding.value) //=&gt;666 &#125; &#125;&#125;//然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：&lt;input v-focus=\"6666\"&gt; // 6666 可用data 里面的变量替换，建议传简单数据类型 一个正常的业务不可能只有一个指令，如果把所有的指令都注册在main.js里面会不好管理，所以最好放在一个统一文件 directives.js 这里就产生了两个问题： 1、怎么把directives.js 这个文件引用到main.js 2、Vue.directives() 支不支持链式调用（因为老版本angular 支持，所以做一个假想） 1234567891011121314151617181920212223242526// 第二个问题很好解决，经过测试，Vue.directives() 不支持链式调用 `Vue.directives().directives()`// 第一个问题：经过查阅相关资料之后可以以插件的形式引入// 这种方式引入暂时还没有发现有其他的问题// main.jsimport directives from './directives.js'Vue.use(directives);// directives.jsexport default&#123; // install 方法会默认在main.js里面调用 install(Vue)&#123; Vue.directive('focus',&#123; inserted(el,binding)&#123; el.focus(); &#125; &#125;); Vue.directive('data',&#123; inserted(el)&#123; console.log(el) &#125; &#125;); //有多个就继续往这里添加就好了 &#125;&#125; 四、Vue 过滤器Vue 过滤器的用法 过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。 与指令的用法类似，但过滤器一定要有返回值，也不支持链式调用 这里需要注意的地方是，vue 2.0 之后移除了自带的过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 在双花括号中&#123;&#123; message | capitalize &#125;&#125;// 在 `v-bind` 中&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt;// 局部注册过滤器filters: &#123; // 首字母大写 capitalize: function (value) &#123; // value 就是 ‘|’ 符号前面的值 if (!value) return ''; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125;// 注册全局过滤器Vue.filter('capitalize', function (value) &#123; if (!value) return ''; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)// 过滤器传值&#123;&#123; number | dual(2) &#125;&#125;Vue.filter('dual', function (value,type) &#123; // 回调函数里面默认有 value ,在页面上传过来的值会依次添加在后面 console.log(type) // =&gt; 2 if (!value) return ''; if (typeof value !== \"number\") return alert(value + ' 不是数字'); if( parseInt(type) === 2 )&#123; return value = value &gt; 10 ? value : '0' + value &#125; return value&#125;)// 过滤器的插件用法，与 directives.js 一致// main.jsimport directives from './filters.js'Vue.use(filters);// filters.jsexport default &#123; install(Vue)&#123; Vue.filter('dual', function (value,type) &#123; if (!value) return ''; if (typeof value !== \"number\") return alert(value + ' 不是数字'); if( parseInt(type) === 2 )&#123; return value = value &gt; 10 ? value : '0' + value &#125; return value &#125;) &#125;&#125; 五、Vue 数据监听Vue 数据监听 watch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// watch 基本用法与注意事项data: &#123; a: 1, e: &#123; f: &#123; g: 5 &#125; &#125;, items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ],&#125;mounted: function()&#123; this.a = 2； this.e.f.g = 10; this.$set(this.items, 0, &#123; message: 'AAA' &#125;); // $set 赋值 this.items[0] = &#123; message: 'AAA' &#125;; // 直接赋值&#125;,watch: &#123; // 最简单最直接的监听方式，能监听简单的数据变化，这种方法默认就是执行 handler: function()&#123;&#125; // 注意：这种方式监听不到对象的变化 a: function(val, oldVal)&#123; console.log(val); // =&gt; 变化之后的数据 console.log(oldVal); // =&gt; 变化之前的数据 &#125;, // 深度监听，这里要注意一下，这样的方式打印出来两个值都是变化之后的值 // deep 的值默认为false，如果不写或者deep: false 都不能监听到对象值的变化 e: &#123; handler: function (val, oldVal) &#123; console.log(val); // =&gt; 变化之后的数据 console.log(oldVal); // =&gt; 变化之后的数据 &#125;, deep: true, &#125;, // 如果要精准监听的对象值的变化，可以用这种方法 'e.f.g': function (val, oldVal) &#123; console.log(val); // =&gt; 变化之后的数据 console.log(oldVal); // =&gt; 变化之前的数据 &#125;, // 监听数组 // 由于 JavaScript 的限制，Vue 不能检测 this.items[0] = &#123; message: 'AAA' &#125;; 这种方式赋值的变化 // 所以你要用 $set、或者数组变异的方法赋值 items: function(val, oldVal)&#123; console.log(val); // =&gt; 变化之后的数据 console.log(oldVal); // =&gt; 变化之后的数据 &#125;,&#125; Vue 数组更新检测 官网的介绍：由于 JavaScript 的限制，Vue 不能检测以下变动的数组 换句话来说：这样赋值不触发视图更新 1、当你利用索引直接设置一个项时，例如： 1this.items[indexOfItem] = newValue // indexOfItem 是指数组的index 下标 2、当你修改数组的长度时，例如： 1this.items.length = newLength 要解决上面问题，你可以用以下方式解决： 1、Vue.set( target, key, value) ，set方法有下面3个参数 {Object | Array} target – 给谁设置值（对象，数组）都可以 {string | number} key – 给对象设值，key 就是对象的key，给数组设值，key 就是数组的下标 index {any} value – 添加任何值都可以 2、数组变异的方式push()：将一个或多个元素添加到数组的末尾，并返回新数组的长度。 pop()：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 shift()：从数组中删除第一个元素，并返回该元素的值。 unshift()：将一个或多个元素添加到数组的开头，并返回新数组的长度。 splice()：通过删除现有元素和/或添加新元素来更改一个数组的内容。 sort()：用就地（ in-place ）的算法对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。 reverse()：将数组中元素的位置颠倒。 六、Vue 组件Vue 组件基础 组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。 注意：组件没有 el 这样根实例特有的选项；而根实例没有 props 这个子组件特有的属性 Vue.component( 组件名 ,{ 选项 }) 全局注册 12345678910111213// 全局注册组件的时候必须写在Vue实例创建之前// 下面这几种方式是等价的import Vue from 'vue'var MyComponent = Vue.extend(&#123; template:\"&lt;h1&gt;我是全局组件&lt;/h1&gt;\"&#125;);Vue.component(\"my-component\",MyComponent);// 注册组件，传入一个扩展过的构造器Vue.component('my-component', Vue.extend(&#123; /* ... */ &#125;))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component('my-component', &#123; /* ... */ &#125;) 通常情况下一个组件肯定是由很多html标签组成的，如果全部写在template 里会非常难看且没有语法高亮提示，有没有其他解决办法？还真有 12345678910111213// 一个定义模板的方式是在一个 &lt;script&gt; 元素中，并为其带上 text/x-template 的类型，然后通过一个 id 将模板引用过去。&lt;script type=\"text/x-template\" id=\"hello-world-template\"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;// 另一个定义模板的方式是在一个 &lt;template&gt; 元素中，通过一个 id 将模板引用过去；在单文件组件 .vue 当中，id可以省略；&lt;template id=\"hello-world-template\"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/template&gt;Vue.component(\"my-component\",&#123; template:\"#hello-world-template\"&#125;); 引入外部单文件组件注册成全局组件 12345678910111213141516171819202122232425// .vue // 在单文件组件中 template 标签下只能有一个根元素// 如果硬要有多个根元素，你只能在多个根元素中添加 v-if、v-else-if、v-else 来判断什么时候用哪个根元素&lt;template&gt; &lt;div class=\"home\"&gt; &lt;p&gt;&#123;&#123;getting&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;!-- &lt;p&gt;这样是不行的&lt;/p&gt; --&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"home\", // 便于在vue-devtools 调试中提供更加友好的警告信息 data: function () &#123; return &#123; getting: 'welcome' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;// 局部css样式&lt;/style&gt;// main.jsimport home from './components/home/home'Vue.component('home',home); 局部注册组件 12345678910111213141516171819202122232425// 每个vue 实例都会有一个 components 的选项，而组件是可复用的 Vue 实例，所以每个组件都有components 选项// 引入外部文件注册成局部组件import home from './components/home/home'new Vue(&#123; el:\"#app\", components: &#123; home, // 等价于home: home，ES6对象中属性的简洁表示，ES6(http://es6.ruanyifeng.com/#docs/object) &#125;&#125;);// 直接在components 选项中写，(不推荐这种用法)new Vue(&#123; el:\"#app\", components: &#123; loading: &#123; data: function () &#123; return &#123; getting: 'welcome' &#125; &#125;, components:&#123; // 这里还可以嵌套局部组件... &#125; &#125; &#125;&#125;); 组件间的传值 通过 Prop 向子组件传递数据 注意：这种传值方式是单向数据流，不可逆。 12345678910111213141516171819202122232425// HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。// 这意味着当你使用 DOM 中的模板时，驼峰命名法的 prop 名需要使用其等价的 短横线分隔命名命名。// 如果使用字符串模板，那么这个限制就不存在了。Vue.component('my-component', &#123; props: ['myTitle'], template: '&lt;h3&gt;&#123;&#123; myTitle&#125;&#125;&lt;/h3&gt;'&#125;)// HTML&lt;my-component my-title='hello world'&gt;&lt;/my-component&gt;// 上述例子只是一个静态数据传输，如果你要动态传输数据，可以用 v-bind 绑定一个属性// 也可以用v-bind 的缩写形式&lt;my-component v-bind:my-title='hello world'&gt;&lt;/my-component&gt; // 任何类型的值都可以传递给 prop，prop 允许很多个// 如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind，如：obj: &#123; id: 1, title: 'Hello World'&#125;&lt;my-component v-bind='obj'&gt;&lt;/my-component&gt;// 等价于：&lt;my-component v-bind:id='obj.id' v-bind:title='obj.title'&gt;&lt;/my-component&gt; Prop 还提供验证的方式指定传什么值 123456789101112131415161718192021222324252627282930313233Vue.component(&apos;my-component&apos;, &#123; props: &#123; // 基础的类型检查 (`null` 匹配任何类型) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组且一定会从一个工厂函数返回默认值 default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 既然 prop 的单向的，那如果子组件向父组件传值怎么办？ 子传父，使用 自定义事件 的方式 1234567891011121314151617181920212223// 子组件,子组件可以通过$emit() 广播一个事件给父组件// 命名的这个事件名没有限制，子组件与父组件的名字保持一致就可以了&lt;button v-on:click=\"$emit('broadcast')\"&gt;向父组件广播这个事件&lt;/button&gt;// $emit() 这个方法也可以写在 子组件的 methods 里面&lt;button v-on:click=\"broadcast\"&gt;向父组件广播这个事件&lt;/button&gt;methods: &#123; broadcast()&#123; this.$emit('broadcast') // 如果要传值，就使用$emit(事件名, 值) 的第二个参数 this.$emit('broadcast', value) &#125;&#125; // 在父组件中，父组件可以用 v-on 监听子组件触发的 `broadcast` 事件，类似监听Dom 事件一样的用法&lt;my-component v-on:broadcast='catchYou'&gt;&lt;/my-component&gt;methods: &#123; catchYou(val)&#123; // 子组件传过来的值就会作为第一个参数传入这个方法 console.log(val) &#125;&#125; // 在组件的表达式里面，你可以通过$event 访问到子组件传递过来的值&lt;my-component v-on:broadcast='$event'&gt;&lt;/my-component&gt; 组件的一些其他用法，感兴趣可以去了解 插槽 动态组件 &amp; 异步组件 单元素/组件的过渡 七、vue-router 贴一段 app 构建的案例。官网API 点这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 这里我让 app.vue作为最大的渲染层，渲染tabs --&gt;&lt;!-- 这里我模拟的是一个商场app，下面几个tab；点击`tab`直接渲染在`tabs`的&lt;router-view&gt;&lt;/router-view&gt;上 --&gt;&lt;!-- tabs 之外的页面直接渲染在app.vue 的&lt;router-view&gt;&lt;/router-view&gt;上 --&gt;&lt;!-- app.vue --&gt;&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;!-- tabs.vue --&gt;&lt;div class=\"tabs\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;nav class=\"nav\"&gt; &lt;router-link class=\"nav-link\" to=\"home\"&gt; &lt;i&gt;&lt;/i&gt; &lt;p&gt;首页&lt;/p&gt; &lt;/router-link&gt; &lt;nav&gt;&lt;/div&gt;// 以下一些配置是简单要用到的，高级的用法请看官网// router.jsimport tabs from './components/tabs/tabs'import home from './components/home/home'const router = new VueRouter(&#123; mode: 'history', // 可选值: \"hash\" 、 \"history\" 、 \"abstract\" linkActiveClass: 'active', // 默认值: \"router-link-active\" 全局配置 &lt;router-link&gt; 的默认『激活 class 类名』 routes: [ &#123; path: \"/tabs\", // 指向的路径 name: \"tabs\", // 命名路由，可以通过这个名称跳转到这个组件 component: tabs, // 指向路径加载的组件 children: [ // 嵌套路由也有跟父级一样的选项 &#123; path:\"home\", name: \"home\", component: home, &#125; ] &#125;, &#123; path: '/', redirect: '/tabs/home' // 重定向，即无目标地址的时候转到这个路径 &#125; ]&#125;);export default router;// main.jsimport router from './router.js'new Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount('#app'); router-link 的几种跳转方式 12345678910111213141516&lt;!-- 字符串模式，可以说是静态模式，不用v-bind --&gt;&lt;router-link to=\"home\"&gt;Home&lt;/router-link&gt;&lt;!-- 下面几种是动态模式 --&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to=\"'home'\"&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to=\"'home'\"&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=\"&#123; path: 'home' &#125;\"&gt;Home&lt;/router-link&gt;&lt;!-- 跳转到命名的路由 --&gt;&lt;!-- 这里有需要注意的地方是，如果路由有传值，那这里的params 就不能省略--&gt;&lt;router-link :to=\"&#123; name: 'user' , params: &#123; userId &#125;&#125;\"&gt;User&lt;/router-link&gt; router 传值的几种方式 注意：如果提供了 path，params 会被忽略，取而代之的是提供路由的 name 或手写完整的带有参数的 path，同样的规则也适用于 router-link 组件的 to 属性 另外的传参方式，有兴趣可以了解一下 props 12345678910// 在函数里面this.$router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;)this.$router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // `$&#123; &#125;` 是ES6 的模板字符串概念，标识符是 ` `// 这里的 params 不生效this.$router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;)// router-link 传值&lt;router-link :to=\"&#123; name: 'user',params: &#123; userId &#125; &#125;\"&gt;User&lt;/router-link&gt;&lt;router-link :to=\"&#123; path: `/user/$&#123;userId&#125;` &#125;\"&gt;User&lt;/router-link&gt;// 这里的 params 不生效&lt;router-link :to=\"&#123; path: '/user', params: &#123; userId &#125;&#125;\"&gt;User&lt;/router-link&gt; 目标组件取值 这里要很小心，是 this.$route，不是 this.$router，没有 r 的 12// 使用这种方式获取路由传过来的值this.$route.params.userId 路由的命名视图，这里贴的是官网的例子，官网API 点这里 1234567891011121314151617&lt;!-- html --&gt;&lt;router-view class=\"view one\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view two\" name=\"a\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view three\" name=\"b\"&gt;&lt;/router-view&gt;// jsconst router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; // 这里的 `components` 要跟上面的 `component` 区分一下，有多个视图渲染的时候有 `s`，别漏了 default: Foo, // 这是默认指定的 Foo 这个组件，也就是在没有命名的&lt;router-view&gt;上渲染 a: Bar, // 这里一一对应有 name 属性的&lt;router-view&gt;就可以了 b: Baz &#125; &#125; ]&#125;) 几种导航的方法，官网 点这里 下面几种方法跟 window.history 的几种方法很像，其实就是仿照 window.history 1234567891011121314151617181920// 往路由历史新增一条记录，相关参数参考官网this.$router.push(location, onComplete?, onAbort?)// 替换掉当前的记录this.$router.replace(location, onComplete?, onAbort?)// 在浏览器记录中前进一步，等同于 this.$router.forward()this.$router.go(1)this.$router.forward()// 后退一步记录，等同于 this.$router.back()this.$router.go(-1)this.$router.back()// 前进 3 步记录this.$router.go(3)// 如果 history 记录不够用，那就默默地失败呗this.$router.go(-100)this.$router.go(100) 路由跳转的时候支持过度动效，感兴趣可以去玩一下，官网 点这里 （还有其他更加高级的用法要靠自己去查阅了） 八、axiosaxios 英文文档 axios 中文文档 — 对英文文档的翻译 axios 是基于 ES6 的 Promise 写的，具体可以看 Promise 相关说明 12// npm 安装npm i axiso // 等价于 npm install axios ，i 是 install 的简写 axios 的一些简单用法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// GET 请求// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;);// POST 请求axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 执行多个并发请求function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;// 这两个方法返回的都是 Promise 对象，这两个请求方法都成功返回的时候，下面方法才返回成功。// 这两个方法中有一个返回不成功就算返回失败 axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 通过向 axios 传递相关配置来创建请求 axios(config) 123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); axios(url[, config]) 12// 发送 GET 请求（默认的方法）axios('/user/12345'); 为方便，axios 还为支持的请求方法提供了别名，如： 注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 还有其他高级用法，具体请查阅官网 axios 英文文档","categories":[],"tags":[],"keywords":[]},{"title":"java面对对象总结","slug":"java面对对象总结","date":"2019-10-24T03:24:24.000Z","updated":"2019-10-24T03:26:47.374Z","comments":true,"path":"2019/10/24/java面对对象总结/","link":"","permalink":"http://yoursite.com/2019/10/24/java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/","excerpt":"","text":"第一章:java 环境搭建第一点. 架构a) 搭建（model）模型层，创建实体类 b) 搭建（service）控制层，创建服务类 c) 搭建（tool）工具层，创建工具类 第二点. 命名规范a) 类名首字母应该大写。字段、方法以及对象（句柄）的首字母应小写。对于所有标识符，其中包含的所有单词都应紧靠在一起，而且大写中间单词的首字母。 b) 不能以数字开头，名称只能由字母、数字、下划线、$符号组成，称不能使用JAVA中的关键字，不允许出现中文及拼音 第二章： 类和对象的创建第一点. 构造方法a) 构造方法名称和类名相同，没有返回值类型，构造方法主要的作用是给成员变量初始化赋值 第二点. 构造方法重载a) 如果同一个类中包含了两个及以上的方法，它们的方法名相同，但参数或参数类型不同则称之为方法从在，成员方法和构造方法都可以重载 第三点. Statica) Static通常用来修饰属性，方法和代码块，被修饰的代码之间存放在内存中，无论是否执行 第三章： 封装第一点. 封装概述a) 封装是指将对象的属性私有化，不允许外部程序直接访问，通过该类提供的方法实现对内部信息的操作 第二点. 封装好处a) 提高了安全性 b) 提高了复用性 c) 隐藏了实现细节 第三点. 封装使用步骤a) 将属性私有化 b) 定义get和set方法，在方法内部设置取值范围 c) 拥抱get和set进行调用 第四点. 封转注意事项a) 类的属性均用（private）私有修饰符 第五点. 封转的访问权限 修饰符 同一个类 同一个包 子类 所有类 Private（私有的） * Defaule(默认) * * Protected * * * Public（公共的） * * * * 第四章： 继承第一点. 继承的使用a) 子类继承父类所有的属性和方法，只能调用父类的非private属性和方法 b) Java只支持单继承，但允许多层继承 c) 1234567 [修饰符] class 类名 extends 父类｛ 属性定义 方法定义｝ 第二点. 继承中的构造方法a) Super关键字 b) Super和this很像，区别是this是调用本地的对象，方法，属性；super是调用父类的 c) Super（）：调用父类的有参构造方法，不再调用父类的无参构造方法 d) 无论子类调用是否有参，在继承中只调用父类无参构造方法，如果父类没有无参构造方法则必须调用父类有参构造方法 第三点. 重写a) 重写称为方法的覆盖，即子类的方法名，返回值，类型参数及个数完全相同，唯一不同的只是方法的实现内容，这种称为重写 第四点. 异常处理a) Try{ }catch( ){ }块 i. 当try中代码执行完不会发生异常时则忽略catch ii. 当try中代码执行有问题是则用catch捕获 b) 常见异常类型 异常 说明 Exception 异常层次结构的根类（必须放在最后，因为它范围最大） ArithmeticException 算数错误，如以零作为除数 ArraylndexOutOfBoundsException 数组下标越界 NullPointerException 空指针异常 ClassNotFoundExceotion 不能加载所需类 InputMismatchExceotion 得到的数据类型与实际类型不符 ClassCastException 对象强制类型转换出现错误 IllegalArgumentException 方法接到非法参数 NumberFormatException 数字歌手转换异常 第五章： 多态第一点. 多态概述a) 多态是指不同类的对象对同一消息做出不同相应 b) 多态存在的3个必要条件: i. 要有继承，要有重写，父类引用指向子类对象 c) 多态好处： i. 可替换性 ii. 可扩充性 iii. 接口性 iv. 简化性 第二点. 多态使用a) 向上继承 i. 子类向父类的转换称为向上转型 ii. &lt;父类型&gt;&lt;引用变量明&gt;=new&lt;子类型&gt;(); b) 向下继承 i. 将一个指向子类对象的父类引用赋给一个子类的引用，即将父类类型转换为子类类型，称为向下转型 ii. 向下转型必须经过向上转型才能得到父类型的引用变量 iii. &lt;子类型&gt;&lt;引用变量名&gt;=(&lt;子类型&gt;) &lt;父类型的引用变量&gt; 第三点. Instanceof运算符a) 在向下转型的过程从可以进行判断是否转型成功 第四点. Try-catch-finall块a) Finall里面的内容无论是否发生异常均被执行 第五点. 多重catch块a) 可以捕获多个不同类型的异常 第六章： 抽象第一点. 抽象类a) 抽象就是用程序的逻辑方法和数据结构来模拟现实生活中的世界 b) 抽象类就是用来被继承的，没有具体的实例，无法被new出对象 c) 语法：public abstract class 类名｛｝ d) 抽象类中可以写普通方法，但必须至少有一个抽象方法 第二点. 抽象方法a) 抽象方法没有方法体 b) 语法：public abstract 返回值类型 方法名（参数列表）； c) 子类必须重写父类的抽象方法 第三点. 注意项a) 包含抽象方法的一定是抽象类 b) 抽象类中不一定都是抽象方法 c) 构造方法不能被声明为抽象方法 d) Abstact不能与 public，static，final，native并列修饰同一个方法 第四点. Final修饰符a) Final修饰的类不能被继承 b) 因为不能被继承所以该类中的方法默认都是final修饰 c) 该类如果不需要有子类，不需要重写，不需要被扩展就用final修饰 d) Final修饰的方法可以被继承不可被重写 e) Final修饰的对象则该对象的引用不能改变，但值可以改变 f) Final修饰的属性变为常量，值不可更改 第七章： 接口第一点. 什么是接口a) 接口是一套规范，满足规范的设备就可以组装到一起 第二点. 语法a) [修饰符] interface 借口名extends父接口1，父接口2~~｛｝ b) Class 类名 extends 父类名 implements 接口1,接口2~~ {} 第三点. 注意事项a) 接口的命名规则与类相同 b) 接口中只能定义常量不能定义变量 c) 接口中所有的方法都是抽象方法 d) 接口不实例化，不能有构造方法 e) 接口的实现类必须实现接口的全部方法 第八章： 集合框架第一点. 定义a) 集合是存储对象最常见的一种方式（容器） 第二点. 内容a) Java集合分为两大类Collection和Map b) 区别： i. Collection接口存储一组不唯一（允许重复）、无序的对象 ii. Set接口继承Collection接口，存储一组唯一（不允许重复）、无序的对象 iii. List接口继承Collection接口，存储一组不唯一（允许重复）、有序（以元素插入次序）的对象 iv. Map接口存储一组成对的键-值对象，体统key（键）到value(值)的射影 第三点. List接口a) List接口分为ArrayList与LinkedList b) 创建方法： i. List 名称=new ArrayList(); ii. LinkedList 名称=new LinkedList(); c) 区别为： i. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构 ii. 对于随机访问git和set,ArrayList优于LinkedList，因为LinkedList要移动指针 iii. 对于新增和删除操作add和remove，LinkedLIst占优势，因为ArrayList要移动数据 d) List常见的方法 方法名称 说明 add(object o) 在列表末尾顺序添加元素，起始索引位置从0开始 add(int index,object o) 在指定位置添加指定内容 int sitze() 返回列表中元素个数 get(int index) 返回指定位置的元素 contains(object o) 判断列表中是否存在之指定元素 remove(object o) 从列表中删除元素 remove(int index) 删除指定位置元素 e) LinkedList集合的特殊方法 方法 作用 addFirst(object o) 在列表首部添加元素 addLast(object o) 在列表尾部添加元素 getFirst() 返回列表中的第一个元素 getLast() 返回列表中的最后一个元素 removeFirst() 删除并返回第一个 rermoveLast() 删除并返回最后一个 第四点. Map集合类a) 专门用来处理键值关系的数据 b) Map map=new HastMap(); c) Map常用方法 方法名称 说明 put(object key,object value) 键值对应进行存储 键不可重复，值可以重复 get(object o) 返回键相关联的值,没有返回null remove(object o) 删除指定键的映射 size() 返回元素个数 keyset() 返回键的集合 values() 返回值的集合 containsKey(object o) 存在指定的键值则返回true isEmpty() 不存在键值关系返回true cleat() 从此映射中删除所有映射 第五点. 泛型集合a) 泛型集合是指在创建集合对象时之ID那个集合中的元素，从集合中抽取元素时无需进行转换 b) 例： i. Map&lt;String, ArrayList&gt;Commodity=new HashMap&lt;String, ArrayList&gt;(); 第九章： 文件操作第一点. 什么是流a) 在java中所读到的信息，是通过一根管道，输送到数据文件中的，这根管道中的信息称之为流（Stream）。而在java程序中打开流这个操作称之为写（write） 第二点. 字节输出流写文件1234567891011121314//指定文件夹String lj=&quot;D:/java\\\\as.txt&quot;; /* * 字节输出流 */FileOutputStream out=new FileOutputStream(lj);String str=&quot;dsfsdfwefw&quot;;//将字符串转换为字节byte [] words=str.getBytes();//将数据写到文件中//(文件名,第几位开始,第几位结束);out.write(words,0,words.length);//关闭输出流out.close(); 第三点. 字符输出流写文件123456789101112//指定文件夹String lj=&quot;D:/java\\\\as.txt&quot;;/* * 字符串输出流 */FileWriter fw=new FileWriter(lj);//写入内容fw.write(&quot;我热爱java@_@&quot;);//刷新输出流fw.flush();//关闭输出流fw.close(); 第四点. 字节输入流读文件1234567891011121314//指定文件夹String lj=&quot;D:/java\\\\as.txt&quot;;//创建对象 InputStream input=new FileInputStream(lj);//读取单个字符 input.read();//将数据读取到字节数组中input.read(byte [] b);//从输入流中读取最多len长度的字符，保存到字符数组b中，保存位置从off开始input.read(btye [] b,int off,int len);//返回输入流读取的估计字节数input.available();//关闭输入流input.close(); 第五点. 字符输入流独文件123456789101112//指定文件夹String lj=&quot;D:/java\\\\as.txt&quot;;//创建对象 FileReader input=new FileReader(lj);//读取单个字符 input.read();//将数据读取到字节数组中input.read(byte [] b);//从输入流中读取最多len长度的字符，保存到字符数组b中，保存位置从off开始input.read(btye [] b,int off,int len);//关闭输入流input.close(); 第十章： 多线程第一点. 线程创建方式1： 12345678910111213141516//1.定义一个类实现Runnable接口public class MyThreadOne implements Runnable&#123; //2.实现接口中唯一的run()方法 public void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;这是启用Runnable接口创建的子线程&quot;); &#125;&#125;//3.声明一个线程实体public class Establish &#123; public static void main(String[] args) &#123; MyThreadOne myThraedOne=new MyThreadOne(); //4.通过start()方法启动 new Thread(myThraedOne).start(); &#125;&#125; 方式2： 123456789101112131415//1.创建MyThread并继承Thread类public class Mythread extends Thread()&#123; //2.实现Thread中的run类 public void run()&#123; System.in.println(&quot;这是继承Tread类创建的子线程&quot;); &#125;&#125;//3.生成对象public class Establish &#123; public static void main(String[] args) &#123; Mythread Mythread=new Mythread(); //4.通过start()方法启动 Mythread.start(); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-24T02:28:30.464Z","updated":"2019-10-24T02:28:30.464Z","comments":true,"path":"2019/10/24/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}